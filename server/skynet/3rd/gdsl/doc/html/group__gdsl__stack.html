<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>gdsl: Stack manipulation module</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">gdsl
   &#160;<span id="projectnumber">1.7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__gdsl__stack.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Stack manipulation module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _gdsl_stack *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GDSL stack type.  <a href="#gaed560443d2612fcdb10a55a51687cbbb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc</a> (const char *NAME, <a class="el" href="group__gdsl__types.html#ga32a9b4e8b9665183c2741d28a5ced64f">gdsl_alloc_func_t</a> ALLOC_F, <a class="el" href="group__gdsl__types.html#ga2c6b3f96b291b5b39d2799f93e350053">gdsl_free_func_t</a> FREE_F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stack.  <a href="#ga226386196ca32ee4eae9441f9229a990"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gac115f451db17f6509048018bdef1ffe6">gdsl_stack_free</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a stack.  <a href="#gac115f451db17f6509048018bdef1ffe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga2ad434c6a6cd2e66033195a9cee5919f">gdsl_stack_flush</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a stack.  <a href="#ga2ad434c6a6cd2e66033195a9cee5919f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaf8e7609d8785a3c5f458b996aa42baef">gdsl_stack_get_name</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Getsthe name of a stack.  <a href="#gaf8e7609d8785a3c5f458b996aa42baef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga240a364616309e15eb374469af80a019">gdsl_stack_get_size</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a stack.  <a href="#ga240a364616309e15eb374469af80a019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the growing factor of a stack.  <a href="#ga89fc03e3da09672b366c6e3f1dd3bb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#gaf6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga05718ea5cff27449f3f63e2d7bdbea3b">gdsl_stack_is_empty</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a stack is empty.  <a href="#ga05718ea5cff27449f3f63e2d7bdbea3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaa8464560e005bf2cb91fa12055359b95">gdsl_stack_get_top</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the top of a stack.  <a href="#gaa8464560e005bf2cb91fa12055359b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga09b1e39af6f153586bcd44be16678fd8">gdsl_stack_get_bottom</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bottom of a stack.  <a href="#ga09b1e39af6f153586bcd44be16678fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gac1ae848edf02e7e2ce06ce0f0b84c249">gdsl_stack_set_name</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, const char *NEW_NAME)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of a stack.  <a href="#gac1ae848edf02e7e2ce06ce0f0b84c249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gab913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a> G)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the growing factor of a stack.  <a href="#gab913e793c095b977856a3367a58ea161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gac3566b143b4e3129719840660c9824b3">gdsl_stack_insert</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, void *VALUE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element in a stack (PUSH).  <a href="#gac3566b143b4e3129719840660c9824b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaab5fda5eded58afa96fe179937697940">gdsl_stack_remove</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from a stack (POP).  <a href="#gaab5fda5eded58afa96fe179937697940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaabe9364e7e4d4df0ec2c43a9c94f17bd">gdsl_stack_search</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#ga200177a9a1ac3f2363e228b0e5faeda7">gdsl_compare_func_t</a> COMP_F, void *VALUE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a particular element in a stack.  <a href="#gaabe9364e7e4d4df0ec2c43a9c94f17bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga025af567070bbc933a380c4efcf8a529">gdsl_stack_search_by_position</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a> POS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for an element by its position in a stack.  <a href="#ga025af567070bbc933a380c4efcf8a529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga09c4e7d90846c987e009070395db9519">gdsl_stack_map_forward</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#ga2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a> MAP_F, void *USER_DATA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a stack from bottom to top.  <a href="#ga09c4e7d90846c987e009070395db9519"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaaec1bfd42894b1d163a59f3a06194c93">gdsl_stack_map_backward</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#ga2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a> MAP_F, void *USER_DATA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a stack from top to bottom.  <a href="#gaaec1bfd42894b1d163a59f3a06194c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga5862ed3924559830be65c7e6b364d217">gdsl_stack_write</a> (const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all the elements of a stack to a file.  <a href="#ga5862ed3924559830be65c7e6b364d217"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gace0385f078efc764f4da7bf68b71942a">gdsl_stack_write_xml</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the content of a stack to a file into XML.  <a href="#gace0385f078efc764f4da7bf68b71942a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gacdd3cfc7a7060ecc8278be39a7a79219">gdsl_stack_dump</a> (<a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the internal structure of a stack to a file.  <a href="#gacdd3cfc7a7060ecc8278be39a7a79219"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaed560443d2612fcdb10a55a51687cbbb"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_t" ref="gaed560443d2612fcdb10a55a51687cbbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _gdsl_stack* <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GDSL stack type. </p>
<p>This type is voluntary opaque. Variables of this kind could'nt be directly used, but by the functions of this module. </p>

<p>Definition at line <a class="el" href="gdsl__stack_8h_source.html#l00053">53</a> of file <a class="el" href="gdsl__stack_8h_source.html">gdsl_stack.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga226386196ca32ee4eae9441f9229a990"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_alloc" ref="ga226386196ca32ee4eae9441f9229a990" args="(const char *NAME, gdsl_alloc_func_t ALLOC_F, gdsl_free_func_t FREE_F)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> <a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>NAME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga32a9b4e8b9665183c2741d28a5ced64f">gdsl_alloc_func_t</a>&#160;</td>
          <td class="paramname"><em>ALLOC_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga2c6b3f96b291b5b39d2799f93e350053">gdsl_free_func_t</a>&#160;</td>
          <td class="paramname"><em>FREE_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new stack. </p>
<p>Allocate a new stack data structure which name is set to a copy of NAME. The functions pointers ALLOC_F and FREE_F could be used to respectively, alloc and free elements in the stack. These pointers could be set to NULL to use the default ones:</p>
<ul>
<li>the default ALLOC_F simply returns its argument</li>
<li>the default FREE_F does nothing</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>nothing. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">NAME</td><td>The name of the new stack to create </td></tr>
    <tr><td class="paramname">ALLOC_F</td><td>Function to alloc element when inserting it in a stack </td></tr>
    <tr><td class="paramname">FREE_F</td><td>Function to free element when deleting it from a stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly allocated stack in case of success. </dd>
<dd>
NULL in case of insufficient memory. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gac115f451db17f6509048018bdef1ffe6" title="Destroy a stack.">gdsl_stack_free()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#ga2ad434c6a6cd2e66033195a9cee5919f" title="Flush a stack.">gdsl_stack_flush()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac115f451db17f6509048018bdef1ffe6"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_free" ref="gac115f451db17f6509048018bdef1ffe6" args="(gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#gac115f451db17f6509048018bdef1ffe6">gdsl_stack_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a stack. </p>
<p>Deallocate all the elements of the stack S by calling S's FREE_F function passed to <a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990" title="Create a new stack.">gdsl_stack_alloc()</a>. The name of S is deallocated and S is deallocated itself too.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990" title="Create a new stack.">gdsl_stack_alloc()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#ga2ad434c6a6cd2e66033195a9cee5919f" title="Flush a stack.">gdsl_stack_flush()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ad434c6a6cd2e66033195a9cee5919f"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_flush" ref="ga2ad434c6a6cd2e66033195a9cee5919f" args="(gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#ga2ad434c6a6cd2e66033195a9cee5919f">gdsl_stack_flush</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a stack. </p>
<p>Deallocate all the elements of the stack S by calling S's FREE_F function passed to <a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990" title="Create a new stack.">gdsl_stack_alloc()</a>. S is not deallocated itself and S's name is not modified.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to flush </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990" title="Create a new stack.">gdsl_stack_alloc()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gac115f451db17f6509048018bdef1ffe6" title="Destroy a stack.">gdsl_stack_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8e7609d8785a3c5f458b996aa42baef"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_name" ref="gaf8e7609d8785a3c5f458b996aa42baef" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__gdsl__stack.html#gaf8e7609d8785a3c5f458b996aa42baef">gdsl_stack_get_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Getsthe name of a stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Q must be a valid gdsl_stack_t </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The returned string MUST NOT be freed. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the name from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the stack S. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gac1ae848edf02e7e2ce06ce0f0b84c249" title="Set the name of a stack.">gdsl_stack_set_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga240a364616309e15eb374469af80a019"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_size" ref="ga240a364616309e15eb374469af80a019" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a> <a class="el" href="group__gdsl__stack.html#ga240a364616309e15eb374469af80a019">gdsl_stack_get_size</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of a stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the size from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements of the stack S (noted |S|). </dd></dl>

</div>
</div>
<a class="anchor" id="ga89fc03e3da09672b366c6e3f1dd3bb4c"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_growing_factor" ref="ga89fc03e3da09672b366c6e3f1dd3bb4c" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a> <a class="el" href="group__gdsl__stack.html#ga89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the growing factor of a stack. </p>
<p>Get the growing factor of the stack S. This value is the amount of cells to reserve for next insertions. For example, if you set this value to 10, each time the number of elements of S reaches 10, then 10 new cells will be reserved for next 10 insertions. It is a way to save time for insertions. This value is 1 by default and can be modified with <a class="el" href="group__gdsl__stack.html#gab913e793c095b977856a3367a58ea161" title="Set the growing factor of a stack.">gdsl_stack_set_growing_factor()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the growing factor from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the growing factor of the stack S. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gac3566b143b4e3129719840660c9824b3" title="Insert an element in a stack (PUSH).">gdsl_stack_insert()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gab913e793c095b977856a3367a58ea161" title="Set the growing factor of a stack.">gdsl_stack_set_growing_factor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga05718ea5cff27449f3f63e2d7bdbea3b"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_is_empty" ref="ga05718ea5cff27449f3f63e2d7bdbea3b" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#gaf6a258d8f3ee5206d682d799316314b1">bool</a> <a class="el" href="group__gdsl__stack.html#ga05718ea5cff27449f3f63e2d7bdbea3b">gdsl_stack_is_empty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a stack is empty. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the stack S is empty. </dd>
<dd>
FALSE if the stack S is not empty. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8464560e005bf2cb91fa12055359b95"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_top" ref="gaa8464560e005bf2cb91fa12055359b95" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#gaa8464560e005bf2cb91fa12055359b95">gdsl_stack_get_top</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the top of a stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the top from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element contained at the top position of the stack S if S is not empty. The returned element is not removed from S. </dd>
<dd>
NULL if the stack S is empty. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga09b1e39af6f153586bcd44be16678fd8" title="Get the bottom of a stack.">gdsl_stack_get_bottom()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga09b1e39af6f153586bcd44be16678fd8"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_bottom" ref="ga09b1e39af6f153586bcd44be16678fd8" args="(const gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#ga09b1e39af6f153586bcd44be16678fd8">gdsl_stack_get_bottom</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the bottom of a stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the bottom from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element contained at the bottom position of the stack S if S is not empty. The returned element is not removed from S. </dd>
<dd>
NULL if the stack S is empty. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gaa8464560e005bf2cb91fa12055359b95" title="Get the top of a stack.">gdsl_stack_get_top()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac1ae848edf02e7e2ce06ce0f0b84c249"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_set_name" ref="gac1ae848edf02e7e2ce06ce0f0b84c249" args="(gdsl_stack_t S, const char *NEW_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> <a class="el" href="group__gdsl__stack.html#gac1ae848edf02e7e2ce06ce0f0b84c249">gdsl_stack_set_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>NEW_NAME</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the name of a stack. </p>
<p>Change the previous name of the stack S to a copy of NEW_NAME.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to change the name </td></tr>
    <tr><td class="paramname">NEW_NAME</td><td>The new name of S </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the modified stack in case of success. </dd>
<dd>
NULL in case of insufficient memory. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gaf8e7609d8785a3c5f458b996aa42baef" title="Getsthe name of a stack.">gdsl_stack_get_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab913e793c095b977856a3367a58ea161"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_set_growing_factor" ref="gab913e793c095b977856a3367a58ea161" args="(gdsl_stack_t S, ulong G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#gab913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a>&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the growing factor of a stack. </p>
<p>Set the growing factor of the stack S. This value is the amount of cells to reserve for next insertions. For example, if you set this value to 10, each time the number of elements of S reaches 10, then 10 new cells will be reserved for next 10 insertions. It is a way to save time for insertions. To know the actual value of the growing factor, use <a class="el" href="group__gdsl__stack.html#ga89fc03e3da09672b366c6e3f1dd3bb4c" title="Get the growing factor of a stack.">gdsl_stack_get_growing_factor()</a></p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to get the growing factor from </td></tr>
    <tr><td class="paramname">G</td><td>The new growing factor of S. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the growing factor of the stack S. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gac3566b143b4e3129719840660c9824b3" title="Insert an element in a stack (PUSH).">gdsl_stack_insert()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#ga89fc03e3da09672b366c6e3f1dd3bb4c" title="Get the growing factor of a stack.">gdsl_stack_get_growing_factor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac3566b143b4e3129719840660c9824b3"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_insert" ref="gac3566b143b4e3129719840660c9824b3" args="(gdsl_stack_t S, void *VALUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#gac3566b143b4e3129719840660c9824b3">gdsl_stack_insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VALUE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an element in a stack (PUSH). </p>
<p>Allocate a new element E by calling S's ALLOC_F function on VALUE. ALLOC_F is the function pointer passed to <a class="el" href="group__gdsl__stack.html#ga226386196ca32ee4eae9441f9229a990" title="Create a new stack.">gdsl_stack_alloc()</a>. The new element E is the inserted at the top position of the stack S. If the number of elements in S reaches S's growing factor (G), then G new cells are reserved for future insertions into S to save time.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to insert in </td></tr>
    <tr><td class="paramname">VALUE</td><td>The value used to make the new element to insert into S </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the inserted element E in case of success. </dd>
<dd>
NULL in case of insufficient memory. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gab913e793c095b977856a3367a58ea161" title="Set the growing factor of a stack.">gdsl_stack_set_growing_factor()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#ga89fc03e3da09672b366c6e3f1dd3bb4c" title="Get the growing factor of a stack.">gdsl_stack_get_growing_factor()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gaab5fda5eded58afa96fe179937697940" title="Remove an element from a stack (POP).">gdsl_stack_remove()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab5fda5eded58afa96fe179937697940"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_remove" ref="gaab5fda5eded58afa96fe179937697940" args="(gdsl_stack_t S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#gaab5fda5eded58afa96fe179937697940">gdsl_stack_remove</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an element from a stack (POP). </p>
<p>Remove the element at the top position of the stack S.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to remove the top from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the removed element in case of success. </dd>
<dd>
NULL in case of S is empty. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gac3566b143b4e3129719840660c9824b3" title="Insert an element in a stack (PUSH).">gdsl_stack_insert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaabe9364e7e4d4df0ec2c43a9c94f17bd"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_search" ref="gaabe9364e7e4d4df0ec2c43a9c94f17bd" args="(const gdsl_stack_t S, gdsl_compare_func_t COMP_F, void *VALUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#gaabe9364e7e4d4df0ec2c43a9c94f17bd">gdsl_stack_search</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga200177a9a1ac3f2363e228b0e5faeda7">gdsl_compare_func_t</a>&#160;</td>
          <td class="paramname"><em>COMP_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VALUE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a particular element in a stack. </p>
<p>Search for the first element E equal to VALUE in the stack S, by using COMP_F to compare all S's element with.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; COMP_F != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to search the element in </td></tr>
    <tr><td class="paramname">COMP_F</td><td>The comparison function used to compare S's element with VALUE </td></tr>
    <tr><td class="paramname">VALUE</td><td>The value to compare S's elements with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the first founded element E in case of success. </dd>
<dd>
NULL if no element is found. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga025af567070bbc933a380c4efcf8a529" title="Search for an element by its position in a stack.">gdsl_stack_search_by_position()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga025af567070bbc933a380c4efcf8a529"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_search_by_position" ref="ga025af567070bbc933a380c4efcf8a529" args="(const gdsl_stack_t S, ulong POS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#ga025af567070bbc933a380c4efcf8a529">gdsl_stack_search_by_position</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga9c34ac44da309b004570530c8cec8a0e">ulong</a>&#160;</td>
          <td class="paramname"><em>POS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for an element by its position in a stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; POS &gt; 0 &amp; POS &lt;= |S| </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to search the element in </td></tr>
    <tr><td class="paramname">POS</td><td>The position where is the element to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element at the POS-th position in the stack S. </dd>
<dd>
NULL if POS &gt; |L| or POS &lt;= 0. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gaabe9364e7e4d4df0ec2c43a9c94f17bd" title="Search for a particular element in a stack.">gdsl_stack_search()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga09c4e7d90846c987e009070395db9519"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_map_forward" ref="ga09c4e7d90846c987e009070395db9519" args="(const gdsl_stack_t S, gdsl_map_func_t MAP_F, void *USER_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#ga09c4e7d90846c987e009070395db9519">gdsl_stack_map_forward</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a>&#160;</td>
          <td class="paramname"><em>MAP_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>USER_DATA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a stack from bottom to top. </p>
<p>Parse all elements of the stack S from bottom to top. The MAP_F function is called on each S's element with USER_DATA argument. If MAP_F returns GDSL_MAP_STOP, then <a class="el" href="group__gdsl__stack.html#ga09c4e7d90846c987e009070395db9519" title="Parse a stack from bottom to top.">gdsl_stack_map_forward()</a> stops and returns its last examinated element.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; MAP_F != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to parse </td></tr>
    <tr><td class="paramname">MAP_F</td><td>The map function to apply on each S's element </td></tr>
    <tr><td class="paramname">USER_DATA</td><td>User's datas passed to MAP_F Returns the first element for which MAP_F returns GDSL_MAP_STOP. Returns NULL when the parsing is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gaaec1bfd42894b1d163a59f3a06194c93" title="Parse a stack from top to bottom.">gdsl_stack_map_backward()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaec1bfd42894b1d163a59f3a06194c93"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_map_backward" ref="gaaec1bfd42894b1d163a59f3a06194c93" args="(const gdsl_stack_t S, gdsl_map_func_t MAP_F, void *USER_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdsl__types.html#ga0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> <a class="el" href="group__gdsl__stack.html#gaaec1bfd42894b1d163a59f3a06194c93">gdsl_stack_map_backward</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#ga2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a>&#160;</td>
          <td class="paramname"><em>MAP_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>USER_DATA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a stack from top to bottom. </p>
<p>Parse all elements of the stack S from top to bottom. The MAP_F function is called on each S's element with USER_DATA argument. If MAP_F returns GDSL_MAP_STOP, then <a class="el" href="group__gdsl__stack.html#gaaec1bfd42894b1d163a59f3a06194c93" title="Parse a stack from top to bottom.">gdsl_stack_map_backward()</a> stops and returns its last examinated element.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; MAP_F != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to parse </td></tr>
    <tr><td class="paramname">MAP_F</td><td>The map function to apply on each S's element </td></tr>
    <tr><td class="paramname">USER_DATA</td><td>User's datas passed to MAP_F </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the first element for which MAP_F returns GDSL_MAP_STOP. </dd>
<dd>
NULL when the parsing is done. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga09c4e7d90846c987e009070395db9519" title="Parse a stack from bottom to top.">gdsl_stack_map_forward()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5862ed3924559830be65c7e6b364d217"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_write" ref="ga5862ed3924559830be65c7e6b364d217" args="(const gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#ga5862ed3924559830be65c7e6b364d217">gdsl_stack_write</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&#160;</td>
          <td class="paramname"><em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>USER_DATA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write all the elements of a stack to a file. </p>
<p>Write the elements of the stack S to OUTPUT_FILE, using WRITE_F function. Additionnal USER_DATA argument could be passed to WRITE_F.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL &amp; WRITE_F != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to write. </td></tr>
    <tr><td class="paramname">WRITE_F</td><td>The write function. </td></tr>
    <tr><td class="paramname">OUTPUT_FILE</td><td>The file where to write S's elements. </td></tr>
    <tr><td class="paramname">USER_DATA</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gace0385f078efc764f4da7bf68b71942a" title="Write the content of a stack to a file into XML.">gdsl_stack_write_xml()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gacdd3cfc7a7060ecc8278be39a7a79219" title="Dump the internal structure of a stack to a file.">gdsl_stack_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gace0385f078efc764f4da7bf68b71942a"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_write_xml" ref="gace0385f078efc764f4da7bf68b71942a" args="(gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#gace0385f078efc764f4da7bf68b71942a">gdsl_stack_write_xml</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&#160;</td>
          <td class="paramname"><em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>USER_DATA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the content of a stack to a file into XML. </p>
<p>Write the elements of the stack S to OUTPUT_FILE, into XML language. If WRITE_F != NULL, then uses WRITE_F to write S's elements to OUTPUT_FILE. Additionnal USER_DATA argument could be passed to WRITE_F.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to write. </td></tr>
    <tr><td class="paramname">WRITE_F</td><td>The write function. </td></tr>
    <tr><td class="paramname">OUTPUT_FILE</td><td>The file where to write S's elements. </td></tr>
    <tr><td class="paramname">USER_DATA</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga5862ed3924559830be65c7e6b364d217" title="Write all the elements of a stack to a file.">gdsl_stack_write()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gacdd3cfc7a7060ecc8278be39a7a79219" title="Dump the internal structure of a stack to a file.">gdsl_stack_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacdd3cfc7a7060ecc8278be39a7a79219"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_dump" ref="gacdd3cfc7a7060ecc8278be39a7a79219" args="(gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__gdsl__stack.html#gacdd3cfc7a7060ecc8278be39a7a79219">gdsl_stack_dump</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdsl__stack.html#gaed560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdsl__types.html#gafc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&#160;</td>
          <td class="paramname"><em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>USER_DATA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the internal structure of a stack to a file. </p>
<p>Dump the structure of the stack S to OUTPUT_FILE. If WRITE_F != NULL, then uses WRITE_F to write S's elements to OUTPUT_FILE. Additionnal USER_DATA argument could be passed to WRITE_F.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The stack to write. </td></tr>
    <tr><td class="paramname">WRITE_F</td><td>The write function. </td></tr>
    <tr><td class="paramname">OUTPUT_FILE</td><td>The file where to write S's elements. </td></tr>
    <tr><td class="paramname">USER_DATA</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga5862ed3924559830be65c7e6b364d217" title="Write all the elements of a stack to a file.">gdsl_stack_write()</a> </dd>
<dd>
<a class="el" href="group__gdsl__stack.html#gace0385f078efc764f4da7bf68b71942a" title="Write the content of a stack to a file into XML.">gdsl_stack_write_xml()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Wed Jun 12 2013 18:18:47 for gdsl by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
